<!DOCTYPE HTML>
<html lang="zh_cn" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>æ·»åŠ æ”¶è—å¤¹ - åŸºäº Rust å’Œ GTK 4 çš„ GUI å¼€å‘</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">ç®€ä»‹</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> å®‰è£…</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> é¡¹ç›®è®¾ç½®</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> æ§ä»¶</a></li><li class="chapter-item expanded "><a href="g_object_concepts.html"><strong aria-hidden="true">5.</strong> GObject ç›¸å…³æ¦‚å¿µ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="g_object_memory_management.html"><strong aria-hidden="true">5.1.</strong> å†…å­˜ç®¡ç†</a></li><li class="chapter-item expanded "><a href="g_object_subclassing.html"><strong aria-hidden="true">5.2.</strong> å­ç±»åŒ–</a></li><li class="chapter-item expanded "><a href="g_object_values.html"><strong aria-hidden="true">5.3.</strong> æ³›å‹å€¼</a></li><li class="chapter-item expanded "><a href="g_object_properties.html"><strong aria-hidden="true">5.4.</strong> å±æ€§</a></li><li class="chapter-item expanded "><a href="g_object_signals.html"><strong aria-hidden="true">5.5.</strong> ä¿¡å·</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> ä¸»äº‹ä»¶å¾ªç¯</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> è®¾ç½®(Settings)</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> ä¿å­˜çª—å£çŠ¶æ€</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> åˆ—è¡¨æ§ä»¶</a></li><li class="chapter-item expanded "><a href="composite_templates.html"><strong aria-hidden="true">10.</strong> å¤åˆæ¨¡æ¿</a></li><li class="chapter-item expanded "><a href="todo_1.html"><strong aria-hidden="true">11.</strong> åˆ›å»ºä¸€ä¸ªç®€å•çš„å¾…åŠäº‹é¡¹åº”ç”¨</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_2.html"><strong aria-hidden="true">13.</strong> æ§åˆ¶å¾…åŠäº‹é¡¹åº”ç”¨çš„çŠ¶æ€</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="libadwaita.html"><strong aria-hidden="true">15.</strong> Libadwaita</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="todo_3.html"><strong aria-hidden="true">15.1.</strong> è®©å¾…åŠäº‹é¡¹åº”ç”¨ä½¿ç”¨ Libadwaita</a></li><li class="chapter-item expanded "><a href="todo_4.html" class="active"><strong aria-hidden="true">15.2.</strong> æ·»åŠ æ”¶è—å¤¹</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">åŸºäº Rust å’Œ GTK 4 çš„ GUI å¼€å‘</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Mario-Hero/GTK-Rust-Book-zh_cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="æ·»åŠ æ”¶è—å¤¹"><a class="header" href="#æ·»åŠ æ”¶è—å¤¹">æ·»åŠ æ”¶è—å¤¹</a></h1>
<h2 id="ä¾§è¾¹æ "><a class="header" href="#ä¾§è¾¹æ ">ä¾§è¾¹æ </a></h2>
<p>ä»…ä»…ä½¿ç”¨ Libadwaita ï¼Œå¾…åŠäº‹é¡¹åº”ç”¨çš„å¤–è§‚å’Œæ„Ÿè§‰æ–¹é¢å·²ç»æœ‰äº†ä¸€ä¸ªå¾ˆå¤§çš„é£è·ƒã€‚ è®©æˆ‘ä»¬æ›´è¿›ä¸€æ­¥ï¼Œæ·»åŠ ä¸€ç§å°†ä»»åŠ¡åˆ†ç»„ä¸ºæ”¶è—å¤¹çš„æ–¹æ³•ã€‚ è¿™äº›é›†åˆå°†åœ¨åº”ç”¨ç¨‹åºçš„å·¦ä¾§è·å¾—è‡ªå·±çš„è¾¹æ ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬æ·»åŠ ä¸€ä¸ªæ²¡æœ‰ä»»ä½•åŠŸèƒ½çš„ç©ºç™½ä¾§è¾¹æ ã€‚</p>
<div style="text-align:center"><img src="img/todo_7_sidebar.png" alt="To-Do app with an empty sidebar"/></div>
<p>è¦è¾¾åˆ°è¿™ç§çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦ç»è¿‡å‡ ä¸ªæ­¥éª¤ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å¿…é¡»ç”¨ <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.ApplicationWindow.html"><code>adw::ApplicationWindow</code></a>  æ›¿æ¢ <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a>. ä¸¤è€…çš„ä¸»è¦åŒºåˆ«åœ¨äº <code>adw::ApplicationWindow</code> æ²¡æœ‰æ ‡é¢˜æ åŒºåŸŸã€‚ å½“æˆ‘ä»¬ä½¿ç”¨ <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.NavigationSplitView.html"><code>adw::NavigationSplitView</code></a> æ„å»ºç•Œé¢æ—¶ï¼Œè¿™å°±æ´¾ä¸Šäº†ç”¨åœºã€‚ åœ¨ä¸Šé¢çš„æˆªå›¾ä¸­ï¼Œ<code>NavigationSplitView</code> ä¸ºå·¦è¾¹çš„æ”¶è—å¤¹è§†å›¾æ·»åŠ äº†ä¸€ä¸ªä¾§è¾¹æ ï¼Œè€Œä»»åŠ¡è§†å›¾åˆ™å æ®äº†å³è¾¹çš„ç©ºé—´ã€‚ ä½¿ç”¨ <code>adw::ApplicationWindow</code> æ—¶ï¼Œé›†åˆè§†å›¾å’Œä»»åŠ¡è§†å›¾éƒ½æœ‰å„è‡ªçš„ <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.HeaderBar.html"><code>adw::HeaderBar</code></a>æ ï¼Œè€Œåˆ†éš”çº¿åˆ™ç©¿è¿‡æ•´ä¸ªçª—å£ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt;      
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
        &lt;property name="min-sidebar-width"&gt;200&lt;/property&gt;
        &lt;property name="sidebar"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Collection view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
        &lt;property name="content"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Task view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p><code>NavigationSplitView</code> è¿˜æœ‰åŠ©äºä½¿æ‚¨çš„åº”ç”¨ç¨‹åºå…·æœ‰<a href="https://developer.gnome.org/hig/guidelines/adaptive.html">è‡ªé€‚åº”èƒ½åŠ›</a>ã€‚ä¸€æ—¦è¯·æ±‚çš„å¤§å°å¤ªå°ï¼Œæ— æ³•åŒæ—¶å®¹çº³æ‰€æœ‰å­è§†å›¾ï¼Œåˆ†å‰²è§†å›¾å°±ä¼šæŠ˜å ï¼Œå¹¶å¼€å§‹åƒ <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a> é‚£æ ·å·¥ä½œã€‚ è¿™æ„å‘³ç€å®ƒä¸€æ¬¡åªèƒ½æ˜¾ç¤ºä¸€ä¸ªå­è§†å›¾ã€‚ ä»…æ˜¾ç¤ºå•å¼ çš„è‡ªé€‚åº”è¡Œä¸ºå…è®¸å¾…åŠäº‹é¡¹åº”ç”¨åœ¨è¾ƒå°å±å¹•å°ºå¯¸ï¼ˆå¦‚æ‰‹æœºï¼‰ä¸Šè¿è¡Œï¼Œå³ä½¿æ·»åŠ äº†æ”¶è—å¤¹è§†å›¾ã€‚</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_7_navigation_sidebar.webm" type="video/webm">
   <p>A video which shows that reduzing the width of the app let's the sidebar collapse</p>
 </video>
</div>
<p>æˆ‘ä»¬ä¸ºæ”¶è—å¤¹è§†å›¾æ·»åŠ äº†å¿…è¦çš„ç”¨æˆ·ç•Œé¢å…ƒç´ ï¼Œå¦‚å¸¦æœ‰æ·»åŠ æ–°æ”¶è—å¤¹æŒ‰é’®çš„æ ‡é¢˜æ ï¼Œä»¥åŠç¨åæ˜¾ç¤ºæ”¶è—çš„åˆ—è¡¨æ¡† <code>collections_list</code>. æˆ‘ä»¬è¿˜ä¸º <code>collections_list</code> æ·»åŠ äº†<a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/style-classes.html#sidebars">å¯¼èˆªä¾§è¾¹æ (navigations-sidebar)</a>æ ·å¼ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" bind-source="TodoWindow"
    bind-property="title" bind-flags="sync-create" /&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;child type="start"&gt;
            &lt;object class="GtkToggleButton"&gt;
              &lt;property name="icon-name"&gt;list-add-symbolic&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;New Collection&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkListBox" id="collections_list"&gt;
              &lt;style&gt;
                &lt;class name="navigation-sidebar" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
</code></pre>
<p>æˆ‘ä»¬è¿˜ä¸ºä»»åŠ¡è§†å›¾æ·»åŠ äº†æ ‡é¢˜æ ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" translatable="yes"&gt;Tasks&lt;/property&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;property name="show-title"&gt;False&lt;/property&gt;
          &lt;child type="end"&gt;
            &lt;object class="GtkMenuButton"&gt;
              &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
              &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;Main Menu&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="AdwClamp"&gt;
              &lt;property name="maximum-size"&gt;400&lt;/property&gt;
              &lt;property name="tightening-threshold"&gt;300&lt;/property&gt;
              &lt;property name="child"&gt;
                &lt;object class="GtkBox"&gt;
                  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
                  &lt;property name="margin-start"&gt;12&lt;/property&gt;
                  &lt;property name="margin-end"&gt;12&lt;/property&gt;
                  &lt;property name="spacing"&gt;12&lt;/property&gt;
                  &lt;child&gt;
                    &lt;object class="GtkEntry" id="entry"&gt;
                      &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Taskâ€¦&lt;/property&gt;
                      &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                  &lt;child&gt;
                    &lt;object class="GtkListBox" id="tasks_list"&gt;
                      &lt;property name="visible"&gt;False&lt;/property&gt;
                      &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                      &lt;style&gt;
                        &lt;class name="boxed-list" /&gt;
                      &lt;/style&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                &lt;/object&gt;
              &lt;/property&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/property&gt;
&lt;/object&gt;
</code></pre>
<p>æˆ‘ä»¬è¿˜å¿…é¡»è°ƒæ•´çª—å£çš„å®ç°ã€‚ ä¾‹å¦‚ï¼Œæˆ‘ä»¬çª—å£çš„çˆ¶ç±»å‹ç°åœ¨æ˜¯ <code>adw::ApplicationWindow</code>ï¼Œè€Œä¸æ˜¯ <code>gtk::ApplicationWindow</code>.</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    //                ğŸ‘‡ changed
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>è¿™ä¹Ÿæ„å‘³ç€æˆ‘ä»¬å¿…é¡»å®ç° <code>AdwApplicationWindowImpl</code> trait.</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    //                ğŸ‘‡ changed
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all adwaita application windows
impl AdwApplicationWindowImpl for Window {}</code></pre>
<p>æœ€åï¼Œæˆ‘ä»¬å°† <code>adw::ApplicationWindow</code> æ·»åŠ åˆ° <code>mod.rs </code>ä¸­ <code>Window</code> çš„ç¥–å…ˆä¸­ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/mod.rs">listings/todo/7/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        //       ğŸ‘‡ changed
        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="å ä½é¡µé¢ç©ºé¡µé¢"><a class="header" href="#å ä½é¡µé¢ç©ºé¡µé¢">å ä½é¡µé¢ï¼ˆç©ºé¡µé¢ï¼‰</a></h2>
<p>åœ¨å¼€å§‹å¡«å……æ”¶è—å¤¹è§†å›¾ä¹‹å‰ï¼Œæˆ‘ä»¬è¿˜åº”è¯¥è€ƒè™‘ä¸€ä¸ªä¸åŒçš„æŒ‘æˆ˜ï¼šå¾…åŠäº‹é¡¹åº”ç”¨ç¨‹åºçš„ç©ºçŠ¶æ€ã€‚ åœ¨æ­¤ä¹‹å‰ï¼Œæ²¡æœ‰ä»»ä½•ä»»åŠ¡çš„ç©ºçŠ¶æ€è¿˜ç®—ä¸é”™ã€‚ å¾ˆæ˜æ˜¾ï¼Œæ‚¨å¿…é¡»åœ¨è¾“å…¥æ ä¸­æ·»åŠ ä»»åŠ¡ã€‚ ä½†ç°åœ¨æƒ…å†µä¸åŒäº†ã€‚ ç”¨æˆ·å¿…é¡»å…ˆæ·»åŠ ä¸€ä¸ªæ”¶è—å¤¹ï¼Œæˆ‘ä»¬å¿…é¡»æ˜ç¡®è¿™ä¸€ç‚¹ã€‚ GNOME HIG å»ºè®®ä¸ºæ­¤ä½¿ç”¨ä¸€ä¸ª[å ä½é¡µé¢](<a href="https://developer.gnome.org/hig/patterns/feedback/placeholders.html">Placeholder Pages - GNOME Human Interface Guidelines</a>)ã€‚ åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œå¦‚æœç”¨æˆ·åœ¨æ²¡æœ‰ä»»ä½•æ”¶è—çš„æƒ…å†µä¸‹æ‰“å¼€åº”ç”¨ç¨‹åºï¼Œè¿™ä¸ªå ä½é¡µé¢å°±ä¼šæ˜¾ç¤ºç»™ç”¨æˆ·ã€‚</p>
<div style="text-align:center"><img src="img/todo_8_placeholder_page.png" alt="The placeholder page"/></div>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å°†ç”¨æˆ·ç•Œé¢å°è£…åœ¨ <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>ä¸­ã€‚ ä¸€ä¸ªå †æ ˆé¡µé¢æè¿°å ä½é¡µé¢ï¼Œå¦ä¸€ä¸ªæè¿°ä¸»é¡µé¢ã€‚ æˆ‘ä»¬ç¨åå°†åœ¨ Rust ä»£ç ä¸­è®¾ç½®æ˜¾ç¤ºæ­£ç¡®å †æ ˆé¡µé¢çš„é€»è¾‘ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt; 
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="GtkStack" id="stack"&gt;
        &lt;property name="transition-type"&gt;crossfade&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;placeholder&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="GtkBox"&gt;
                &lt;!--Placeholder page implementation--&gt; 
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;main&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
                &lt;!--Main page implementation--&gt;
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>ä¸ºäº†åˆ›å»ºä¹‹å‰æ˜¾ç¤ºçš„åˆ†é¡µç¬¦é¡µé¢ï¼Œæˆ‘ä»¬å°†æ‰å¹³æ ‡é¢˜æ ä¸ <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StatusPage.html"><code>adw::StatusPage</code></a> ç»“åˆèµ·æ¥ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="GtkBox"&gt;
  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
  &lt;child&gt;
    &lt;object class="GtkHeaderBar"&gt;
      &lt;style&gt;
        &lt;class name="flat" /&gt;
      &lt;/style&gt;
    &lt;/object&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;object class="GtkWindowHandle"&gt;
      &lt;property name="vexpand"&gt;True&lt;/property&gt;
      &lt;property name="child"&gt;
        &lt;object class="AdwStatusPage"&gt;
          &lt;property name="icon-name"&gt;checkbox-checked-symbolic&lt;/property&gt;
          &lt;property name="title" translatable="yes"&gt;No Tasks&lt;/property&gt;
          &lt;property name="description" translatable="yes"&gt;Create some tasks to start using the app.&lt;/property&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkButton"&gt;
              &lt;property name="label" translatable="yes"&gt;_New Collection&lt;/property&gt;
              &lt;property name="use-underline"&gt;True&lt;/property&gt;
              &lt;property name="halign"&gt;center&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
              &lt;style&gt;
                &lt;class name="pill" /&gt;
                &lt;class name="suggested-action" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/child&gt;
&lt;/object&gt;
</code></pre>
<h2 id="æ”¶è—å¤¹"><a class="header" href="#æ”¶è—å¤¹">æ”¶è—å¤¹</a></h2>
<p>æˆ‘ä»¬ä»ç„¶éœ€è¦ä¸€ç§æ–¹æ³•æ¥å­˜å‚¨æˆ‘ä»¬çš„æ”¶è—å¤¹ã€‚ å°±åƒæˆ‘ä»¬å·²ç»åˆ›å»ºäº† <code>TaskObject</code> ä¸€æ ·ï¼Œç°åœ¨æˆ‘ä»¬å°†å¼•å…¥ <code>CollectionObject</code>. å®ƒå°†æ‹¥æœ‰<code>æ ‡é¢˜(title)</code>å’Œ<code>ä»»åŠ¡(tasks)</code>ä¸¤ä¸ªæˆå‘˜ï¼Œè¿™ä¸¤ä¸ªæˆå‘˜éƒ½å°†ä½œä¸ºå…¬å¼€å±æ€§ã€‚ åƒå¾€å¸¸ä¸€æ ·ï¼Œç‚¹å‡»ä»£ç ç‰‡æ®µå³ä¸Šæ–¹çš„çœ¼ç›ç¬¦å·å¯ä»¥çœ‹åˆ°å®Œæ•´çš„å®ç°ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/imp.rs">listings/todo/8/collection_object/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::CollectionObject)]
pub struct CollectionObject {
    #[property(get, set)]
    pub title: RefCell&lt;String&gt;,
    #[property(get, set)]
    pub tasks: OnceCell&lt;gio::ListStore&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CollectionObject {
    const NAME: &amp;'static str = "TodoCollectionObject";
    type Type = super::CollectionObject;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CollectionObject {}</span></code></pre>
<p>æˆ‘ä»¬è¿˜æ·»åŠ äº†ç»“æ„ä½“<code>æ”¶è—å¤¹æ•°æ®ï¼ˆCollectionDataï¼‰</code>ï¼Œä»¥å¸®åŠ©å®ç°åºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CollectionObject {
</span><span class="boring">    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("title", title)
</span><span class="boring">            .property("tasks", tasks)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
</span><span class="boring">        let title = self.imp().title.borrow().clone();
</span><span class="boring">        let tasks_data = self
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">        CollectionData { title, tasks_data }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
</span><span class="boring">        let title = collection_data.title;
</span><span class="boring">        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
</span><span class="boring">            .tasks_data
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(TaskObject::from_task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">        tasks.extend_from_slice(&amp;tasks_to_extend);
</span><span class="boring">
</span><span class="boring">        Self::new(&amp;title, tasks)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CollectionData {
    pub title: String,
    pub tasks_data: Vec&lt;TaskData&gt;,
}</code></pre>
<p>æœ€åï¼Œæˆ‘ä»¬ä¸º <code>CollectionObject</code> æ·»åŠ æ–¹æ³•ï¼Œä»¥ä¾¿â€”â€”</p>
<ul>
<li>ç”¨ <code>new</code> åˆ›å»ºå®ƒ,</li>
<li>ç”¨ <code>tasks</code> è½»æ¾è®¿é—® <code>ListStore</code></li>
<li>ä½¿ç”¨ <code>to_collection_data</code> å’Œ <code>from_collection_data</code> ä»»æ„è½¬æ¢ <code>CollectionData</code></li>
</ul>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionObject {
    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
        Object::builder()
            .property("title", title)
            .property("tasks", tasks)
            .build()
    }

    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
        let title = self.imp().title.borrow().clone();
        let tasks_data = self
            .tasks()
            .iter::&lt;TaskObject&gt;()
            .filter_map(Result::ok)
            .map(|task_object| task_object.task_data())
            .collect();
        CollectionData { title, tasks_data }
    }

    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
        let title = collection_data.title;
        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
            .tasks_data
            .into_iter()
            .map(TaskObject::from_task_data)
            .collect();

        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
        tasks.extend_from_slice(&amp;tasks_to_extend);

        Self::new(&amp;title, tasks)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct CollectionData {
</span><span class="boring">    pub title: String,
</span><span class="boring">    pub tasks_data: Vec&lt;TaskData&gt;,
</span><span class="boring">}</span></code></pre>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>ä¸ºäº†è¿æ¥æ–°çš„é€»è¾‘ï¼Œæˆ‘ä»¬å¿…é¡»ä¸º <code>imp::Window</code> æ·»åŠ æ›´å¤šçŠ¶æ€ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡ <code>template_child</code> å®è®¿é—®é¢å¤–çš„æ§ä»¶ã€‚ æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å¼•ç”¨äº† <code>collections</code> åˆ—è¡¨å­˜å‚¨ã€<code>current_collection</code> å’Œ <code>current_filter_model</code>. æˆ‘ä»¬è¿˜å­˜å‚¨äº† <code>tasks_changed_handler_id</code>. å®ƒçš„ä½œç”¨å°†åœ¨åé¢çš„ä»£ç ç‰‡æ®µä¸­è¯´æ˜ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
pub struct Window {
    pub settings: OnceCell&lt;Settings&gt;,
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListBox&gt;,
    // ğŸ‘‡ all members below are new
    #[template_child]
    pub collections_list: TemplateChild&lt;ListBox&gt;,
    #[template_child]
    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
    #[template_child]
    pub stack: TemplateChild&lt;Stack&gt;,
    pub collections: OnceCell&lt;gio::ListStore&gt;,
    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜æ·»åŠ äº†å‡ ä¸ª Helper æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•ç¨åä¼šæ´¾ä¸Šç”¨åœºã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span>    fn tasks(&amp;self) -&gt; gio::ListStore {
        self.current_collection().tasks()
    }

    fn current_collection(&amp;self) -&gt; CollectionObject {
        self.imp()
            .current_collection
            .borrow()
            .clone()
            .expect("`current_collection` should be set in `set_current_collections`.")
    }

    fn collections(&amp;self) -&gt; gio::ListStore {
        self.imp()
            .collections
            .get()
            .expect("`collections` should be set in `setup_collections`.")
            .clone()
    }

    fn set_filter(&amp;self) {
        self.imp()
            .current_filter_model
            .borrow()
            .clone()
            .expect("`current_filter_model` should be set in `set_current_collection`.")
            .set_filter(self.filter().as_ref());
    }
<span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>ä¸€å¦‚æ—¢å¾€ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨å…³é—­çª—å£æ—¶ä¿å­˜æ•°æ®ã€‚ ç”±äºå¤§éƒ¨åˆ†å®ç°éƒ½åœ¨ <code>CollectionObject::to_collection_data</code> æ–¹æ³•ä¸­ï¼Œå› æ­¤ <code>close_request</code> çš„å®ç°å¹¶æ²¡æœ‰å¤ªå¤§å˜åŒ–ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // ğŸ‘‡ all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Store task data in vector
        let backup_data: Vec&lt;CollectionData&gt; = self
            .obj()
            .collections()
            .iter::&lt;CollectionObject&gt;()
            .filter_map(|collection_object| collection_object.ok())
            .map(|collection_object| collection_object.to_collection_data())
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect("Could not create json file.");
        serde_json::to_writer(file, &amp;backup_data)
            .expect("Could not write data to json file");

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>constructed</code> ä¹ŸåŸºæœ¬ä¿æŒä¸å˜ã€‚ æˆ‘ä»¬ç°åœ¨ä¸å†ä½¿ç”¨ <code>setup_tasks</code>ï¼Œè€Œæ˜¯ä½¿ç”¨ <code>setup_collections</code>.</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // ğŸ‘‡ all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_collections();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>setup_collections</code> è®¾ç½® <code>collections</code> åˆ—è¡¨å­˜å‚¨ï¼Œå¹¶ç¡®ä¿æ¨¡å‹ä¸­çš„æ›´æ”¹ä¼šåæ˜ åœ¨ <code>collections_list</code> ä¸­ã€‚ ä¸ºæ­¤ï¼Œå®ƒä½¿ç”¨ <code>create_collection_row</code> æ–¹æ³•ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_collections(&amp;self) {
        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
        self.imp()
            .collections
            .set(collections.clone())
            .expect("Could not set collections");

        self.imp().collections_list.bind_model(
            Some(&amp;collections),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let collection_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `CollectionObject`.");
                    let row = window.create_collection_row(collection_object);
                    row.upcast()
                }
            ),
        )
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>create_collection_row</code> è·å–ä¸€ä¸ª <code>CollectionObject</code> å¹¶æ ¹æ®å…¶ä¿¡æ¯åˆ›å»ºä¸€ä¸ª <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBoxRow.html"><code>gtk::ListBoxRow</code></a>.</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn create_collection_row(
        &amp;self,
        collection_object: &amp;CollectionObject,
    ) -&gt; ListBoxRow {
        let label = Label::builder()
            .ellipsize(pango::EllipsizeMode::End)
            .xalign(0.0)
            .build();

        collection_object
            .bind_property("title", &amp;label, "label")
            .sync_create()
            .build();

        ListBoxRow::builder().child(&amp;label).build()
    }
<span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>æˆ‘ä»¬è¿˜è°ƒæ•´äº† <code>restore_data</code>. åŒæ ·ï¼Œé‡å¤´æˆæ¥è‡ªäº <code>CollectionObject::from_collection_data</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¿…åœ¨è¿™é‡Œåšå¤ªå¤šæ”¹åŠ¨ã€‚ ç”±äº <code>collections_list</code> ä¸­çš„è¡Œå¯ä»¥è¢«é€‰æ‹©ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨è¿˜åŸæ•°æ®åé€‰æ‹©å…¶ä¸­ä¹‹ä¸€ã€‚ æˆ‘ä»¬é€‰æ‹©ç¬¬ä¸€è¡Œï¼Œç„¶åè®© <code>set_current_collection</code> æ–¹æ³•å®Œæˆå‰©ä¸‹çš„å·¥ä½œã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
                .expect(
                    "It should be possible to read `backup_data` from the json file.",
                );

            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
            let collections: Vec&lt;CollectionObject&gt; = backup_data
                .into_iter()
                .map(CollectionObject::from_collection_data)
                .collect();

            // Insert restored objects into model
            self.collections().extend_from_slice(&amp;collections);

            // Set first collection as current
            if let Some(first_collection) = collections.first() {
                self.set_current_collection(first_collection.clone());
            }
        }
    }
<span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>set_current_collection</code> å¯ç¡®ä¿æ‰€æœ‰è®¿é—®ä»»åŠ¡çš„å…ƒç´ éƒ½å¼•ç”¨å½“å‰æ”¶è—å¤¹çš„ä»»åŠ¡æ¨¡å‹ã€‚ æˆ‘ä»¬å°† <code>tasks_list</code> ä¸å½“å‰æ”¶è—å¤¹ç»‘å®šï¼Œå¹¶å­˜å‚¨è¿‡æ»¤æ¨¡å‹ã€‚ åªè¦å½“å‰æ”¶è—å¤¹ä¸­æ²¡æœ‰ä»»åŠ¡ï¼Œæˆ‘ä»¬å°±è¦éšè—ä»»åŠ¡åˆ—è¡¨ã€‚ å¦åˆ™ï¼Œåˆ—è¡¨æ¡†ä¼šç•™ä¸‹ä¸€è¡Œéš¾çœ‹çš„å­—ã€‚ ä¸è¿‡ï¼Œæˆ‘ä»¬ä¸æƒ³åœ¨åˆ‡æ¢é›†åˆæ—¶ç´¯ç§¯ä¿¡å·å¤„ç†å™¨(signal handler)ã€‚ è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦å­˜å‚¨ <code>tasks_changed_handler_id</code>ï¼Œå¹¶åœ¨è®¾ç½®æ–°çš„æ”¶è—å¤¹æ—¶æ–­å¼€æ—§çš„å¤„ç†å™¨(handler)ã€‚ æœ€åï¼Œæˆ‘ä»¬é€‰æ‹©æ”¶è—å¤¹è¡Œã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_current_collection(&amp;self, collection: CollectionObject) {
        // Wrap model with filter and selection and pass it to the list box
        let tasks = collection.tasks();
        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.bind_model(
            Some(&amp;selection_model),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let task_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `TaskObject`.");
                    let row = window.create_task_row(task_object);
                    row.upcast()
                }
            ),
        );

        // Store filter model
        self.imp().current_filter_model.replace(Some(filter_model));

        // If present, disconnect old `tasks_changed` handler
        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
            self.tasks().disconnect(handler_id);
        }

        // Assure that the task list is only visible when it is supposed to
        self.set_task_list_visible(&amp;tasks);
        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |tasks, _, _, _| {
                window.set_task_list_visible(tasks);
            }
        ));
        self.imp()
            .tasks_changed_handler_id
            .replace(Some(tasks_changed_handler_id));

        // Set current tasks
        self.imp().current_collection.replace(Some(collection));

        self.select_collection_row();
    }
<span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>ä¹‹å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† <code>set_task_list_visible</code> æ–¹æ³•ã€‚ è¯¥æ–¹æ³•ç¡®ä¿ <code>tasks_list</code> åªæœ‰åœ¨ä»»åŠ¡æ•°å¤§äº 0 æ—¶æ‰å¯è§ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
    }
<span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>select_collection_row</code> å¯ç¡®ä¿åœ¨ <code>collections_list</code> ä¸­é€‰æ‹©å½“å‰æ”¶è—å¤¹çš„è¡Œã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn select_collection_row(&amp;self) {
        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
            let row = self.imp().collections_list.row_at_index(index as i32);
            self.imp().collections_list.select_row(row.as_ref());
        }
    }
<span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="æ¶ˆæ¯å¯¹è¯"><a class="header" href="#æ¶ˆæ¯å¯¹è¯">æ¶ˆæ¯å¯¹è¯</a></h2>
<p>ç›®å‰è¿˜æ²¡æœ‰æ·»åŠ æ”¶è—å¤¹çš„æ–¹æ³•ã€‚ è®©æˆ‘ä»¬æ¥å®ç°è¿™ä¸€åŠŸèƒ½ã€‚</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_dialog.webm" type="video/webm">
   <p>A video which shows the new dialog</p>
 </video>
</div>
<p>ä¸Šé¢çš„å±å¹•å½•åƒæ¼”ç¤ºäº†æ‰€éœ€çš„è¡Œä¸ºã€‚ å½“æˆ‘ä»¬æŒ‰ä¸‹å¸¦æœ‰ <code>+</code> ç¬¦å·çš„æŒ‰é’®æ—¶ï¼Œä¼šå‡ºç°ä¸€ä¸ªå¯¹è¯æ¡†ã€‚ å½“è¾“å…¥æ¡†ä¸ºç©ºæ—¶ï¼Œ"åˆ›å»º"æŒ‰é’®ä¿æŒä¸æ¿€æ´»ã€‚ ä¸€æ—¦æˆ‘ä»¬å¼€å§‹é”®å…¥ï¼ŒæŒ‰é’®å°±ä¼šæ¿€æ´»ã€‚ å½“æˆ‘ä»¬åˆ é™¤æ‰€æœ‰é”®å…¥çš„å­—æ¯ï¼Œè¾“å…¥æ¡†å†æ¬¡å˜ä¸ºç©ºæ—¶ï¼Œ"åˆ›å»º"æŒ‰é’®å°±ä¼šå˜æš—ï¼Œè¾“å…¥æ¡†å°±ä¼šå˜æˆ "é”™è¯¯" æ ·å¼ã€‚ ç‚¹å‡» "åˆ›å»º" æŒ‰é’®åï¼Œä¸€ä¸ªæ–°çš„æ”¶è—å¤¹å°±åˆ›å»ºå¥½äº†ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥è¿›å…¥å…¶ä»»åŠ¡è§†å›¾ã€‚</p>
<p>ä¸ºäº†å®ç°è¿™ä¸€è¡Œä¸ºï¼Œæˆ‘ä»¬é¦–å…ˆè¦åœ¨ <code>class_init</code> æ–¹æ³•ä¸­æ·»åŠ ä¸€ä¸ª "new-collection" åŠ¨ä½œã€‚ ç‚¹å‡» <code>+</code> æŒ‰é’®å’Œå ä½é¡µé¢ä¸­çš„æŒ‰é’®éƒ½å°†æ¿€æ´»è¯¥æ“ä½œã€‚ æˆ‘ä»¬ä½¿ç”¨<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action_async"><code>install_action_async</code></a>. è¿™æ˜¯ä¸€ç§ä¸ºå­ç±»æ§ä»¶æ·»åŠ å¼‚æ­¥æ“ä½œçš„ä¾¿æ·æ–¹æ³•ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // ğŸ‘‡ all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });

        // Create async action to create new collection and add to action group "win"
        klass.install_action_async(
            "win.new-collection",
            None,
            |window, _, _| async move {
                window.new_collection().await;
            },
        );
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>ä¸€æ—¦ "new-collection" æ“ä½œè¢«æ¿€æ´»ï¼Œ<code>å¼‚æ­¥(async) new_collection</code> æ–¹æ³•å°±ä¼šè¢«è°ƒç”¨ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åˆ›å»º<a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.AlertDialog.html"><code>adw::AlertDialog</code></a>, è®¾ç½®æŒ‰é’®å¹¶æ·»åŠ æ¡ç›®ã€‚ æˆ‘ä»¬ä¸ºæ¡ç›®æ·»åŠ äº†ä¸€ä¸ªå›è°ƒï¼Œä»¥ç¡®ä¿å†…å®¹å‘ç”Ÿå˜åŒ–æ—¶ï¼Œç©ºå†…å®¹ä¼šå°† <code>dialog_button</code> è®¾ç½®ä¸ºä¸æ¿€æ´»ï¼Œå¹¶ä¸ºæ¡ç›®æ·»åŠ ä¸€ä¸ª "é”™è¯¯" CSS ç±»ã€‚ ç„¶åï¼Œæˆ‘ä»¬<code>ç­‰å¾…(await)</code>ç”¨æˆ·æŒ‰ä¸‹å¯¹è¯æ¡†ä¸Šçš„æŒ‰é’®ã€‚ å¦‚æœç”¨æˆ·ç‚¹å‡» "å–æ¶ˆ"ï¼Œæˆ‘ä»¬å°±è¿”å›ã€‚ ä½†æ˜¯ï¼Œå¦‚æœä»–ä»¬ç‚¹å‡» "åˆ›å»º"ï¼Œæˆ‘ä»¬å°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ”¶è—å¤¹ï¼Œå¹¶å°†å…¶è®¾ç½®ä¸ºå½“å‰æ”¶è—å¤¹ã€‚ ç„¶åï¼Œæˆ‘ä»¬åœ¨é¡µé¢ä¸Šå‘å‰å¯¼èˆªï¼Œå¯¼èˆªåˆ°ä»»åŠ¡è§†å›¾ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    async fn new_collection(&amp;self) {
        // Create entry
        let entry = Entry::builder()
            .placeholder_text("Name")
            .activates_default(true)
            .build();

        let cancel_response = "cancel";
        let create_response = "create";

        // Create new dialog
        let dialog = AlertDialog::builder()
            .heading("New Collection")
            .close_response(cancel_response)
            .default_response(create_response)
            .extra_child(&amp;entry)
            .build();
        dialog
            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
        // Make the dialog button insensitive initially
        dialog.set_response_enabled(create_response, false);
        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);

        // Set entry's css class to "error", when there is no text in it
        entry.connect_changed(clone!(
            #[weak]
            dialog,
            move |entry| {
                let text = entry.text();
                let empty = text.is_empty();

                dialog.set_response_enabled(create_response, !empty);

                if empty {
                    entry.add_css_class("error");
                } else {
                    entry.remove_css_class("error");
                }
            }
        ));

        let response = dialog.choose_future(self).await;

        // Return if the user chose `cancel_response`
        if response == cancel_response {
            return;
        }

        // Create a new list store
        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();

        // Create a new collection object from the title the user provided
        let title = entry.text().to_string();
        let collection = CollectionObject::new(&amp;title, tasks);

        // Add new collection object and set current tasks
        self.collections().append(&amp;collection);
        self.set_current_collection(collection);

        // Show the content
        self.imp().split_view.set_show_content(true);
    }
<span class="boring">}</span></code></pre>
<p>æˆ‘ä»¬è¿˜åœ¨ <code>setup_callbacks</code> ä¸­æ·»åŠ äº†æ›´å¤šå›è°ƒã€‚ é‡è¦çš„æ˜¯ï¼Œæ¯å½“ "è¿‡æ»¤ï¼ˆfilterï¼‰"è®¾ç½®çš„å€¼å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæˆ‘ä»¬éƒ½è¦è¿‡æ»¤å½“å‰çš„ä»»åŠ¡æ¨¡å‹ã€‚ æ¯å½“æ”¶è—å¤¹çš„é¡¹ç›®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿè¦è®¾ç½®å †æ ˆã€‚ è¿™æ ·å¯ä»¥ç¡®ä¿åœ¨æ²¡æœ‰æ”¶è—å¤¹çš„æƒ…å†µä¸‹æ˜¾ç¤ºå ä½é¡µé¢ã€‚ æœ€åï¼Œæˆ‘ä»¬ç¡®ä¿å½“æˆ‘ä»¬ç‚¹å‡» <code>collections_list</code> ä¸­çš„ä¸€è¡Œæ—¶ï¼Œ<code>current_collection</code> å°†è¢«è®¾ç½®ä¸ºæ‰€é€‰çš„é›†åˆï¼Œå¹¶åˆ†å‰²è§†å›¾æ˜¾ç¤ºä»»åŠ¡è§†å›¾ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span>        // Filter model whenever the value of the key "filter" changes
        self.settings().connect_changed(
            Some("filter"),
            clone!(
                #[weak(rename_to = window)]
                self,
                move |_, _| {
                    window.set_filter();
                }
            ),
        );

        // Setup callback when items of collections change
        self.set_stack();
        self.collections().connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, _, _, _| {
                window.set_stack();
            }
        ));

        // Setup callback for activating a row of collections list
        self.imp().collections_list.connect_row_activated(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, row| {
                let index = row.index();
                let selected_collection = window
                    .collections()
                    .item(index as u32)
                    .expect("There needs to be an object at this position.")
                    .downcast::&lt;CollectionObject&gt;()
                    .expect("The object needs to be a `CollectionObject`.");
                window.set_current_collection(selected_collection);
                window.imp().split_view.set_show_content(true);
            }
        ));
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>ä¹‹å‰ï¼Œæˆ‘ä»¬è°ƒç”¨äº† <code>set_stack</code> æ–¹æ³•ã€‚ è¯¥æ–¹æ³•ç¡®ä¿åœ¨è‡³å°‘æœ‰ä¸€ä¸ªé›†åˆæ—¶ï¼Œæ˜¾ç¤ºä¸»é¡µé¢ï¼Œå¦åˆ™æ˜¾ç¤º"å ä½"é¡µé¢ã€‚</p>
<p>æ–‡ä»¶åï¼š <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_stack(&amp;self) {
        if self.collections().n_items() &gt; 0 {
            self.imp().stack.set_visible_child_name("main");
        } else {
            self.imp().stack.set_visible_child_name("placeholder");
        }
    }
<span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>å°±æ˜¯è¿™æ ·ï¼ ç°åœ¨æˆ‘ä»¬å¯ä»¥æ¬£èµæœ€ç»ˆæˆæœäº†ã€‚</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_adaptive_sidebar.webm" type="video/webm">
   <p>A video which shows the final To-Do app</p>
 </video>
</div>
<blockquote>
<p>æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œç›®å‰è¿˜æ²¡æœ‰åˆ é™¤æ”¶è—å¤¹çš„æ–¹æ³•ã€‚ è¯·å°è¯•åœ¨æœ¬åœ°ç‰ˆæœ¬çš„å¾…åŠäº‹é¡¹åº”ç”¨ç¨‹åºä¸­å®ç°è¿™ä¸€ç¼ºå¤±åŠŸèƒ½ã€‚ æ‚¨éœ€è¦è€ƒè™‘å“ªäº›è¾¹ç•Œæƒ…å†µï¼Ÿ</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="todo_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="todo_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
